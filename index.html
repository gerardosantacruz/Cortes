<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>Guía de Cortes — Pizza/Torta/Alfajor</title>
<style>
  :root {
    --accent: #22c55e;
  }
  html, body { height: 100%; margin: 0; background: #000; color: #fff; font-family: system-ui, -apple-system, Roboto, Segoe UI, Ubuntu, Cantarell, sans-serif; }
  #app { position: relative; height: 100%; overflow: hidden; }
  /* Video a pantalla completa */
  video {
    position: fixed; inset: 0; width: 100vw; height: 100vh; object-fit: cover;
    transform: none; /* sin espejo por defecto (trasera) */
    background: #000;
  }
  /* Overlay en canvas centrado a viewport */
  canvas {
    position: fixed; inset: 0; width: 100vw; height: 100vh; pointer-events: none;
  }
  /* Crosshair sutil para ayudar a centrar */
  .crosshair { position: fixed; inset: 0; pointer-events: none; }
  .ui {
    position: fixed; left: 0; right: 0; bottom: 0; padding: 12px;
    display: grid; gap: 10px;
    background: linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,.65) 30%, rgba(0,0,0,.85) 100%);
  }
  .panel {
    background: rgba(0,0,0,.55); backdrop-filter: blur(6px);
    border: 1px solid rgba(255,255,255,.12); border-radius: 16px; padding: 10px 12px;
    display: grid; gap: 8px;
  }
  .row { display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 10px; }
  label { font-size: 14px; opacity: .95; }
  select, input[type="range"], button { accent-color: var(--accent); }
  select, button {
    background: rgba(255,255,255,.08); color: #fff; border: 1px solid rgba(255,255,255,.15);
    padding: 8px 10px; border-radius: 10px; font-size: 15px;
  }
  .hint { font-size: 12px; opacity: .8; text-align: center; }
  .topbar {
    position: fixed; left: 0; right: 0; top: 0; display: flex; gap: 8px; padding: 10px;
    justify-content: space-between; align-items: center; pointer-events: none;
  }
  .chip { pointer-events: auto; background: rgba(0,0,0,.55); border: 1px solid rgba(255,255,255,.15); border-radius: 999px; padding: 6px 10px; font-size: 13px; }
  .btn { cursor: pointer; }
</style>
</head>
<body>
<div id="app">
  <video id="video" autoplay playsinline muted></video>
  <canvas id="overlay"></canvas>

  <!-- Guías finas -->
  <svg class="crosshair" viewBox="0 0 100 100" preserveAspectRatio="none">
    <line x1="50" y1="0" x2="50" y2="100" stroke="white" stroke-opacity=".12" stroke-width="0.4"/>
    <line x1="0" y1="50" x2="100" y2="50" stroke="white" stroke-opacity=".12" stroke-width="0.4"/>
  </svg>

  <div class="topbar">
    <span class="chip">Guía de cortes</span>
    <div class="chip" style="display:flex;gap:6px;align-items:center;">
      <label for="cameraSel" style="margin-right:4px;">Cámara</label>
      <select id="cameraSel" title="Elegir cámara"></select>
      <button id="flipBtn" class="btn">↺ Cambiar</button>
    </div>
  </div>

  <div class="ui">
    <div class="panel">
      <div class="row">
        <label for="parts">Partes</label>
        <select id="parts">
          <option>2</option><option selected>3</option><option>4</option><option>5</option>
          <option>6</option><option>8</option><option>10</option><option>12</option>
        </select>
      </div>
      <div class="row">
        <label for="rotation">Rotación (<span id="deg">0</span>°)</label>
        <input id="rotation" type="range" min="0" max="359" value="0" />
      </div>
      <div class="row">
        <label for="circle">Tamaño del círculo</label>
        <input id="circle" type="range" min="10" max="100" value="80" />
      </div>
      <div class="row">
        <label for="showAngles">Mostrar ángulos</label>
        <input id="showAngles" type="checkbox" />
      </div>
      <div class="hint">Arrastrá para rotar. Hacé <b>pinch</b> (dos dedos) para ajustar el tamaño. Para gran angular, elegí la cámara correspondiente.</div>
    </div>
  </div>
</div>

<script>
(() => {
  const video = document.getElementById('video');
  const canvas = document.getElementById('overlay');
  const ctx = canvas.getContext('2d');

  const partsSel = document.getElementById('parts');
  const rot = document.getElementById('rotation');
  const degLabel = document.getElementById('deg');
  const circle = document.getElementById('circle');
  const showAngles = document.getElementById('showAngles');
  const cameraSel = document.getElementById('cameraSel');
  const flipBtn = document.getElementById('flipBtn');

  let angle = 0;
  let rafId;
  let devices = [];
  let currentDeviceId = null;
  let lastTwoTouches = null;

  // --- Layout: canvas = tamaño del viewport (centro real visual)
  function resizeCanvas() {
    const w = window.innerWidth, h = window.innerHeight;
    canvas.width = w; canvas.height = h;
  }
  window.addEventListener('resize', resizeCanvas, { passive: true });
  resizeCanvas();

  // --- Cámara
  async function listCameras() {
    try {
      const list = await navigator.mediaDevices.enumerateDevices();
      devices = list.filter(d => d.kind === 'videoinput');

      cameraSel.innerHTML = '';
      devices.forEach((d, i) => {
        const opt = document.createElement('option');
        const label = d.label || `Cámara ${i+1}`;
        opt.value = d.deviceId;
        opt.textContent = label;
        cameraSel.appendChild(opt);
      });

      // seleccionar actual si está
      if (currentDeviceId) cameraSel.value = currentDeviceId;
    } catch (e) {
      console.warn('No se pudo enumerar cámaras:', e);
    }
  }

  function isFrontLabel(label='') {
    const l = label.toLowerCase();
    return l.includes('front') || l.includes('frontal') || l.includes('user');
  }

  async function startCamera({ deviceId = null, prefer = 'environment' } = {}) {
    try {
      const constraints = {
        audio: false,
        video: deviceId ? { deviceId: { exact: deviceId } } :
               { facingMode: prefer, width: { ideal: 1920 }, height: { ideal: 1080 } }
      };
      const stream = await navigator.mediaDevices.getUserMedia(constraints);

      // parar stream anterior si lo hubiera
      if (video.srcObject) video.srcObject.getTracks().forEach(t => t.stop());
      video.srcObject = stream;

      // detectar deviceId real en uso
      const vtrack = stream.getVideoTracks()[0];
      const settings = vtrack.getSettings();
      currentDeviceId = settings.deviceId || null;

      // espejo solo si es frontal
      // Si tenemos label, lo usamos; si no, inferimos por facingMode si está definido
      let front = false;
      try {
        const all = await navigator.mediaDevices.enumerateDevices();
        const match = all.find(d => d.deviceId === currentDeviceId);
        if (match && match.label) front = isFrontLabel(match.label);
        else if (settings.facingMode) front = (settings.facingMode === 'user');
      } catch {}

      video.style.transform = front ? 'scaleX(-1)' : 'none';

      // refrescar combo de cámaras con labels (solo aparecen tras conceder permisos)
      await listCameras();
      if (currentDeviceId) cameraSel.value = currentDeviceId;
    } catch (e) {
      alert('No se pudo abrir la cámara. Usá HTTPS o concedé permisos.\n' + e.message);
    }
  }

  cameraSel.addEventListener('change', () => {
    const id = cameraSel.value;
    startCamera({ deviceId: id });
  });

  flipBtn.addEventListener('click', () => {
    // ciclo simple: siguiente cámara
    if (!devices.length) return;
    const idx = devices.findIndex(d => d.deviceId === currentDeviceId);
    const next = devices[(idx + 1) % devices.length];
    if (next) startCamera({ deviceId: next.deviceId });
  });

  // --- Interacción: drag = rotar; pinch = cambiar radio
  let dragging = false, lastX = 0;
  canvas.addEventListener('pointerdown', (e) => {
    dragging = true; lastX = e.clientX;
  }, { passive: true });
  window.addEventListener('pointerup', () => dragging = false, { passive: true });
  window.addEventListener('pointermove', (e) => {
    if (!dragging) return;
    const dx = e.clientX - lastX; lastX = e.clientX;
    angle = (angle + dx * 0.3) % 360;
    rot.value = ((Number(rot.value) + dx * 0.3) % 360 + 360) % 360;
    degLabel.textContent = Math.round(rot.value);
  }, { passive: true });

  // soporte básico para pinch-to-zoom (dos dedos)
  window.addEventListener('touchstart', (e) => {
    if (e.touches.length === 2) {
      lastTwoTouches = distance(e.touches[0], e.touches[1]);
    }
  }, { passive: true });

  window.addEventListener('touchmove', (e) => {
    if (e.touches.length === 2 && lastTwoTouches != null) {
      const d = distance(e.touches[0], e.touches[1]);
      const delta = d - lastTwoTouches;
      lastTwoTouches = d;
      const v = Math.min(100, Math.max(10, Number(circle.value) + delta * 0.05));
      circle.value = v.toFixed(0);
    }
  }, { passive: true });

  window.addEventListener('touchend', (e) => {
    if (e.touches.length < 2) lastTwoTouches = null;
  }, { passive: true });

  function distance(a, b) {
    const dx = a.clientX - b.clientX, dy = a.clientY - b.clientY;
    return Math.hypot(dx, dy);
  }

  // --- Controles
  partsSel.addEventListener('input', () => {});
  rot.addEventListener('input', () => {
    angle = Number(rot.value);
    degLabel.textContent = Math.round(angle);
  });
  circle.addEventListener('input', () => {});
  showAngles.addEventListener('change', () => {});

  // --- Dibujo overlay
  function draw() {
    const w = canvas.width, h = canvas.height;
    ctx.clearRect(0, 0, w, h);

    // radio proporcional al lado menor (slider 10..100 => 5%..50% del minDim)
    const r = Math.min(w, h) * (Number(circle.value) / 200);
    const cx = w / 2, cy = h / 2;

    // círculo
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(255,255,255,.9)';
    ctx.lineWidth = 2;
    ctx.setLineDash([]);
    ctx.stroke();

    const n = Number(partsSel.value);
    const step = 360 / n;

    // líneas radiales
    for (let i = 0; i < n; i++) {
      const a = (angle + i * step) * Math.PI / 180;
      const x = cx + Math.cos(a) * r;
      const y = cy + Math.sin(a) * r;

      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(x, y);
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(34,197,94,.95)';
      ctx.setLineDash([8, 8]);
      ctx.stroke();

      if (showAngles.checked) {
        const la = (angle + i * step) % 360;
        const tx = cx + Math.cos(a) * (r + 22);
        const ty = cy + Math.sin(a) * (r + 22);
        ctx.fillStyle = 'rgba(255,255,255,.95)';
        ctx.font = '12px system-ui, -apple-system, Roboto, sans-serif';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(`${Math.round(la)}°`, tx, ty);
      }
    }

    // punto central
    ctx.beginPath();
    ctx.arc(cx, cy, 4, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255,255,255,.95)';
    ctx.fill();

    rafId = requestAnimationFrame(draw);
  }

  // --- Inicio
  (async () => {
    // pedir al menos una vez permisos para obtener labels de cámaras
    await startCamera({ prefer: 'environment' });
    draw();
    // limpieza
    window.addEventListener('pagehide', () => {
      cancelAnimationFrame(rafId);
      if (video.srcObject) video.srcObject.getTracks().forEach(t => t.stop());
    });
  })();
})();
</script>
</body>
</html>
